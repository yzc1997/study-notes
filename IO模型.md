# 五种IO模型

1. 阻塞IO模型
2. 非阻塞IO模型
3. 多路复用IO模型
4. 信号驱动IO模型
5. 异步IO模型

前面四种IO模型实际上都属于 *同步IO*，只有 **异步IO模型** 是真正的 *异步IO*，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。

## 阻塞IO模型

- 最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。
- IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU

## 非阻塞IO模型

- 非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。这就会导致一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高。
- 一般情况下很少使用while循环这种方式来读取数据。

## 多路复用IO模型

- 多路复用IO模型是目前使用得比较多的模型。Java **NIO** 实际上就是多路复用IO。
- 多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。
- 只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。
- 多路复用IO比较适合连接数比较多的情况。
- **Java NIO**多路复用机制在不用的系统中存在差别，在window中选择器是select去轮循channel获取信息，Linux中选择器是epoll通过注册事件回调通知获取信息; 

## 信号驱动IO模型

- 在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，**便在信号函数中调用IO读写操作来进行实际的IO请求操作**。
- 一般用于UDP中，对TCP套接口几乎是没用的，原因是该信号产生得过于频繁，并且该信号的出现并没有告诉我们发生了什么事情

## 异步IO模型

- 异步IO模型是最理想的IO模型，在Java中，可以理解为 **AIO**
- 异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事，然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了，当接收内核返回的成功信号时表示IO操作已经完成，**可以直接去使用数据了（与信号驱动IO模型不同）**。
- 异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成
- 用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作
- 异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。