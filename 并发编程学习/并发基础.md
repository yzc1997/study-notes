# 并发基础

## CPU 多级缓存

- 为什么需要 CPU 缓存
    
    CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，所以cacha的出现，是为了缓解CPU和内存之间速度不匹配的问题的。

    ***cpu > cache > memory***

- CPU 缓存的意义：

    局部性原理

  - 时间局部性：如果某个数据被访问，那么在不久的将来很可能被再次访问。
  - 空间局部性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问。

## 缓存一致性（MESI）

- 缓存一致性用于保证多个CPU 缓存之间缓存共享数据的一致。

### 四种操作状态 - MESI

- M： Modify（被修改）
  - 该缓存行只存在该CPU的缓存中，并且是被修改过的，因此它与主存中的数据是不一致的。该缓存行的内存需要在未来某个时间点写回主存，这个时间点是允许其他CPU读取主存相应的内存之前。当这里的值被写会主存之后，该缓存行的状态会转换为 **E（独享）**


- E： Exclusive（独享、互斥）
  - 该状态的缓存行只被缓存在该 **CPU** 的缓存中，它是未被修改过的，与主存中数据一致。该状态可以在任何时刻，当其他 **CPU** 读取该内存时改变为共享状态 **（shared）**，当 **CPU** 修改该缓存行时，变为 被修改状态 **（Modified）**


- S： Shared（共享）
  - 这个状态意味着该缓存行被多个 **CPU** 共同缓存，并且各缓存行中的数据与主存中数据是一致的。当有其他 **CPU** 修改该缓存行时，其他缓存行是可以被做废的，变成 **（Invalid）**
  - 
- I： Invalid（无效）
  - 代表该缓存是无效的，可能是由其他 **CPU** 修改了该缓存行。

### 四种操作 

- local read 读本地缓存中的数据
- local write 将数据写到本地缓存中
- remote read 读取内存中的数据
- remote write 将数据写回到主存中


## 乱序执行优化

- 处理器为提高运算速度而做出违背代码原有顺序的优化 （单核情况下，运行没有错误）